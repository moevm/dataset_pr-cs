# ЛР 3 Вариант 4
# Суть работы автомата: оторвать первый символ от слова (перенеся его в соседнюю ячейку слева), и последовательно перенести за него остальные символы
# Для этого резервируется место перед словом
# *Реверсом* далее называю перевернутую исходную строку, то есть результат работы программы


# Создаем элементы МТ
memory = 15 * [' ']  # Закладываем место для результата
memory.extend(list(input()))
index = 14  # Пропускаем заведомо пустую область

state = 'q0'
terminator = 'qT'


# Таблица переходов
table = {
        # Найти слово и переместить первый символ, тем самым закладываем реверс
        'q0': {
            'a': ( ' ', 'L', 'q1a'),  # Слово начинается с символа 'a', поэтому определяем поведение только него
            # 'b': ( ' ', 'L', 'q1b'),
            # 'c': ( ' ', 'L', 'q1c'),
            ' ': ( ' ', 'R', 'q0'),  # На ленте точно есть слово, поэтому никак не обрабатываем случай, что его нет
        },

        'q1a': {
            # 'a': ( '', '', ''),
            # 'b': ( '', '', ''),
            # 'c': ( '', '', ''),
            ' ': ( 'a', 'N', 'q2'), # Аналогнично можно поступить, если начинается с произвольного символа алфавита
        },



        # Вернуться к началу реверса
        'q2': {
            'a': ( 'a', 'R', 'q2'),
            'b': ( 'b', 'R', 'q2'),
            'c': ( 'c', 'R', 'q2'),
            ' ': ( ' ', 'N', 'q3'),
        },


    
        # Найти начало слова, проверить есть ли следующий
        'q3': {
            'a': ( 'a', 'R', 'q3t'),
            'b': ( 'b', 'R', 'q3t'),
            'c': ( 'c', 'R', 'q3t'),
            ' ': ( ' ', 'R', 'q3'),
        },

        'q3t': { # t -- test
            'a': ( 'a', 'L', 'q3t_complited'),
            'b': ( 'b', 'L', 'q3t_complited'),
            'c': ( 'c', 'L', 'q3t_complited'),
            ' ': ( ' ', 'L', 'q3t_failed'),
        },

        'q3t_complited': {
            'a': ( ' ', 'N', 'q4a0'),
            'b': ( ' ', 'N', 'q4b0'),
            'c': ( ' ', 'N', 'q4c0'),
            # ' ': ( ' ', 'R', 'q3'),
        },

        'q3t_failed': {
            'a': ( ' ', 'N', 'q4a0_and_terminate'),
            'b': ( ' ', 'N', 'q4b0_and_terminate'),
            'c': ( ' ', 'N', 'q4c0_and_terminate'),
            # ' ': ( ' ', 'R', 'q3'),
        }, 

        # Получилась конструкция if-else



        # Далее состояния дублируются, потому что нет памяти:
        # - куда можно было бы записать переносимый символ
        # - для некого флага, сообщающего состояниям q4__, что нужно завершить -- перейти в qT, а не искать следующий символ -- q2...

        # Найти начало реверса, 'помня' о символе 'a'
        'q4a0': {
            'a': ( 'a', 'N', 'q4a1'),
            'b': ( 'b', 'N', 'q4a1'),
            'c': ( 'c', 'N', 'q4a1'),
            ' ': ( ' ', 'L', 'q4a0'),
        },

        # Найти конец реверса, поставить символ 'a', пойти за следующим
        'q4a1': {
            'a': ( 'a', 'L', 'q4a1'),
            'b': ( 'b', 'L', 'q4a1'),
            'c': ( 'c', 'L', 'q4a1'),
            ' ': ( 'a', 'N', 'q2'),
        },


        # Найти начало реверса, 'помня' о символе 'b'
        'q4b0': {
            'a': ( 'a', 'N', 'q4b1'),
            'b': ( 'b', 'N', 'q4b1'),
            'c': ( 'c', 'N', 'q4b1'),
            ' ': ( ' ', 'L', 'q4b0'),
        },

        # Найти конец реверса, поставить символ 'b', пойти за следующим
        'q4b1': {
            'a': ( 'a', 'L', 'q4b1'),
            'b': ( 'b', 'L', 'q4b1'),
            'c': ( 'c', 'L', 'q4b1'),
            ' ': ( 'b', 'N', 'q2'),
        },


        # Найти начало реверса, 'помня' о символе 'c'
        'q4c0': {
            'a': ( 'a', 'N', 'q4c1'),
            'b': ( 'b', 'N', 'q4c1'),
            'c': ( 'c', 'N', 'q4c1'),
            ' ': ( ' ', 'L', 'q4c0'),
        },

        # Найти конец реверса, поставить символ 'c', пойти за следующим
        'q4c1': {
            'a': ( 'a', 'L', 'q4c1'),
            'b': ( 'b', 'L', 'q4c1'),
            'c': ( 'c', 'L', 'q4c1'),
            ' ': ( 'c', 'N', 'q2'),
        },


    
        # Найти начало реверса, 'помня' о символе 'a'
        'q4a0_and_terminate': {
            'a': ( 'a', 'N', 'q4a1_and_terminate'),
            'b': ( 'b', 'N', 'q4a1_and_terminate'),
            'c': ( 'c', 'N', 'q4a1_and_terminate'),
            ' ': ( ' ', 'L', 'q4a0_and_terminate'),
        },
        
        # Найти конец реверса, поставить символ 'a', закончить
        'q4a1_and_terminate': {
            'a': ( 'a', 'L', 'q4a1_and_terminate'),
            'b': ( 'b', 'L', 'q4a1_and_terminate'),
            'c': ( 'c', 'L', 'q4a1_and_terminate'),
            ' ': ( 'a', 'N', 'qT'),
        },


        # Найти начало реверса, 'помня' о символе 'b'
        'q4b0_and_terminate': {
            'a': ( 'a', 'N', 'q4b1_and_terminate'),
            'b': ( 'b', 'N', 'q4b1_and_terminate'),
            'c': ( 'c', 'N', 'q4b1_and_terminate'),
            ' ': ( ' ', 'L', 'q4b0_and_terminate'),
        },

        # Найти конец реверса, поставить символ 'b', закончить
        'q4b1_and_terminate': {
            'a': ( 'a', 'L', 'q4b1_and_terminate'),
            'b': ( 'b', 'L', 'q4b1_and_terminate'),
            'c': ( 'c', 'L', 'q4b1_and_terminate'),
            ' ': ( 'b', 'N', 'qT'),
        },


        # Найти начало реверса, 'помня' о символе 'c'
        'q4c0_and_terminate': {
            'a': ( 'a', 'N', 'q4c1_and_terminate'),
            'b': ( 'b', 'N', 'q4c1_and_terminate'),
            'c': ( 'c', 'N', 'q4c1_and_terminate'),
            ' ': ( ' ', 'L', 'q4c0_and_terminate'),
        },

        # Найти конец реверса, поставить символ 'c', закончить
        'q4c1_and_terminate': {
            'a': ( 'a', 'L', 'q4c1_and_terminate'),
            'b': ( 'b', 'L', 'q4c1_and_terminate'),
            'c': ( 'c', 'L', 'q4c1_and_terminate'),
            ' ': ( 'c', 'N', 'qT'),
        },
    }
    
    
# Обозначения для направлений
aliases = {
    'R': 1,
    'N': 0,
    'L': -1
}


# Главный цикл
# history = [state]
while state != terminator:
    symbol = memory[index]  # Читаем символ из ячейки

    # Действуем согласно состоянию
    new_symbol, direction, new_state = table[state][symbol]
     
    memory[index] = new_symbol  # Записываем новый сивол в ячейку
    index += aliases[direction]  # Перемещаемся в соседнюю ячейку или остаемся на месте
    state = new_state  # Переходим в новое состояние
    
    # history.append(state)  # История


# Вывод результата
print(''.join(memory)) 

# Вывод истории
# for i, s in enumerate(history):
#   print(i, s)  

